# Day 9: Mirage Maintenance

## Problem Summary

You're at an oasis in the desert using your handy **Oasis And Sand Instability Sensor (OASIS)** to take environmental readings. The sensor produces a report of values changing over time, and you need to predict future and past values to complete the analysis.

Each line in the input is a **history** - a sequence of integers representing measurements over time.

**Input Format:** Space-separated integers on each line, e.g.:
```
0 3 6 9 12 15
1 3 6 10 15 21
10 13 16 21 30 45
```

### Part 1: Predict the Next Value

For each history, extrapolate what the **next value** would be by:
1. Computing successive differences until reaching a sequence of all zeros
2. Working back up, adding the last value of each lower level to the level above

**Example:**
```
0   3   6   9  12  15  [18]  <- extrapolated
  3   3   3   3   3  [3]
    0   0   0   0  [0]
```

### Part 2: Predict the Previous Value

For each history, extrapolate what the **previous value** would be by:
1. Computing the same successive differences
2. Working back up, but this time **subtracting** to find what came before

**Example:**
```
[5]  10  13  16  21  30  45   <- extrapolated
   [5]   3   3   5   9  15
      [-2]  0   2   4   6
         [2]  2   2   2
            [0]  0   0
```

## Algorithmic Approach

### Key Insight

This problem is based on **finite differences** - a discrete analog of derivatives. If a sequence is generated by a polynomial of degree n, taking n successive differences will yield a constant sequence, and taking n+1 differences yields all zeros.

This is related to Pascal's Triangle and Newton's forward/backward difference formulas for polynomial interpolation.

### Algorithm

1. **Parse Input:** Read each line as a sequence of integers

2. **Build Difference Pyramid:**
   ```
   Original:    a  b  c  d  e
   Diff 1:      b-a  c-b  d-c  e-d
   Diff 2:      (c-b)-(b-a)  (d-c)-(c-b)  (e-d)-(d-c)
   ...continue until all zeros...
   ```

3. **Part 1 - Extrapolate Forward:**
   - Add 0 to the zero sequence
   - Work upward: `next[i] = last[i] + next[i+1]`
   - Return the new last value of the original sequence

4. **Part 2 - Extrapolate Backward:**
   - Add 0 to the zero sequence
   - Work upward: `prev[i] = first[i] - prev[i+1]`
   - Return the new first value of the original sequence

### Data Structures Used

- **Array of Arrays:** Store the difference pyramid (each level is one shorter than the previous)
- Simple iteration - no need for complex data structures

### Complexity

- **Time:** O(n * m²) where n = number of histories, m = length of each history
  - For each history, we compute ~m levels of differences
  - Each level requires O(m) operations

- **Space:** O(m²) for storing the pyramid of differences

## Language Notes

### Fast Performers
- **Zig (3.7ms):** Zero-cost abstractions and embedded file loading optimize startup
- **C (4.8ms):** Direct memory manipulation with static arrays
- **ARM64 asm (5.5ms):** Hand-optimized register usage and syscalls

### Standard Performers
- **Perl (17.9ms):** Surprisingly fast with List::Util and native arrays
- **Common Lisp (20.7ms):** Efficient LOOP macro for iteration
- **Python (27.8ms):** Clean list comprehensions work well here

### Slower Performers
- **Bash (1,065ms):** Dynamic variable naming to simulate 2D arrays is expensive
- **ColdFusion (2,373ms):** JVM startup dominates for this simple computation

### Implementation Considerations
- All languages handle signed integers natively - no bignum needed
- The difference pyramid can be stored in-place or separately
- Part 2 can be simplified by just tracking first values without full array prepending

## Benchmarks

| Language    | Runtime (ms) | Memory (MB) |
|-------------|--------------|-------------|
| Zig         | 3.7          | 1.9         |
| C           | 4.8          | 1.8         |
| ARM64 asm   | 5.5          | 1.9         |
| C++         | 6.6          | 2.0         |
| Rust        | 6.5          | 2.0         |
| Perl        | 17.9         | 5.2         |
| Lisp        | 20.7         | 41.0        |
| Python      | 27.8         | 15.8        |
| Node.js     | 42.7         | 42.8        |
| Go          | 48.3         | 26.8        |
| Java        | 49.8         | 50.4        |
| PHP         | 50.1         | 25.9        |
| Ruby        | 58.9         | 28.3        |
| Clojure     | 420.8        | 178.0       |
| Bash        | 1,065.5      | 2.3         |
| ColdFusion  | 2,373.1      | 1,173.9     |

## Answers

- **Part 1:** 1930746032
- **Part 2:** 1154
